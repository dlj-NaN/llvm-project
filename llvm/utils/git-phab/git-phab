#!/usr/bin/env python3
#
# ======- git-phab - Simple Phabricator client ---------*- python -*--========#
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
# ==------------------------------------------------------------------------==#

"""Phabricator client.

This module implements the general top-level logic when running `git phab ...`.

"""

import argparse
import os
import subprocess
import sys
import tempfile

import phab_conduit
import phab_local

# Note that Python 3.3 reached End of Life on 2017-09-29. The next jump should
# probably be to 3.6: Python 3.5 planned EOL is 2019-09-23. Python 3.6 includes
# the bulk of new features that would be useful, like interpolated format
# strings, so intermediate versions may not be particularly useful.
#
# See also: https://devguide.python.org/devcycle/#end-of-life-branches
assert sys.version_info >= (3, 3)


################################################################################
# Background
################################################################################

# This command should be usable in lieu of `arc diff`, for example on systems
# where php is not available. The goal is not to be a fully-featured
# replacement, since a lot of things can be simplified if we know the working
# tree looks more or less like the LLVM monorepo.
#
# `arc` behavior
# ------------------------------------------------------------------------------
#
# For a change to LLVM, the general flow reported by `arc --verbose diff` is:
#
# 1.  Check for a valid HEAD^.
#
# 2.  Find '@{upstream}' and its merge-base.
#
#     If the current branch does not track upstream, arc prompts for the base
#     to use. Something similar is done in `get_upstream_base`, below.
#
# 3.  Find all the commits between the upstream merge-base and HEAD.
#     The equivalent is returned by `get_local_commits`.
#
# (From this point, let's assume there is a single commit to upload.)
#
# 4a. Search existing revisions for the commit.
#
#     Phabricator stores special hashes:
#         gttr: the git tree hash
#         gtcm: the git commit hash
#     (The local hashes can be used to query the API.)
#
# 4b. If no revisions matched the hashes, parse the commit message for the tags
#     that Phabricator usually addes.
#     (This is done by API call, too.)
#
# 4c. If no matching revision was found, a new one will be needed later.
#
# 5.  Create the diff.
#     A "diff" is a separate object from a "differential revision." The arc cli
#     can create a standalone "diff" on Phabricator (`arc diff --preview`), or
#     the web UI upload can also create a standalone diff.
#
# 6.  A bunch of lint checks and Harbormaster stuff usually runs next.
#
# 7.  The local commits are attached to the diff.
#
#     This is the local HEAD, remote base, and tree. These show up in the UI
#     in the "Commits" tab of the revision.
#
# 8.  If a new revision is going to be created, then arc opens an editor with
#     a template based on the commit message.
#
#     The template is generated by API call, based on the commit title and
#
# 9.  The revision is updated to use the newly-created diff.
#
#
# This command's behavior
# ------------------------------------------------------------------------------
#
# In general, this command does less than `arc diff`, even for the constrained
# LLVM monorepo layout.
#
# A few general principles do seem useful, though:
#
# - Include as much usable data as we can. For example, we should make sure to
#   include the baseline hashes in the diff, so that it can be more easily
#   patched by others.
#
# - Cover everything that is needed. This includes updating commit messages so
#   they will be understood by Phabricator after commit.
#
# - Try not to diverge too far from `arc diff` behavior. We're not going to
#   implement everything; but, for the common cases, we don't want to set up any
#   barriers (or any sort of surprises) for folks familiar with Arcanist.


################################################################################
# Subcommand
################################################################################


def cmd_diff(args):
    """Upload local changes to Phabricator for review.

    By default, this will find and upload all changes in the current branch
    since the upstream base.
    """
    dirty_files = phab_local.get_dirty_status()
    if dirty_files:
        print('There are uncommited changes:', file=sys.stderr)
        print(dirty_files, file=sys.stderr)
        print('Please commit before uploading.', file=sys.stderr)
        sys.exit(1)

    arcrc = phab_local.get_arcrc()
    arcconfig = phab_local.get_arcconfig()

    # Determine what we are diffing, and what to diff against.
    head_commit = phab_local.get_ref_hash('HEAD')
    local_branch = phab_local.get_symbolic_ref(head_commit)
    merge_base = phab_local.get_diff_base(args.commit, head_commit)

    if args.verbose:
        print('Local revisions:')
        print('HEAD', head_commit)
        print('branch', local_branch)
        print('merge_base', merge_base)

    # It should be possible to upload sequential diffs for commits, but for now,
    # we'll just treat a range of commits as a single diff.
    diff_commits = phab_local.get_local_commits(merge_base)
    if not diff_commits:
        print('Error: no commits were found for the remote merge-base.',
              file=sys.stderr)
        sys.exit(1)

    diff_text = phab_local.get_raw_diff(merge_base, head_commit)

    with phab_conduit.connect_repository(arcrc, arcconfig) as api:
        # TODO: create a non-raw diff. The raw diff loses info about refs.
        # TODO: avoid creating a diff if nothing changed.
        diff_info = api.create_raw_diff(diff_text)
        diff_phid = diff_info['phid']
        diff_id = int(diff_info['id'])

        if args.diff_only:
            api.update_diff_local_commits(diff_info['id'], diff_commits)
            print('Created diff:', diff_info['uri'])
            return

        # Extract information about this revision from the commit message.
        head_commit = diff_commits[-1]
        commit_fields = api.parse_commit_message(head_commit.message)

        # If we didn't get a specific revision, see if there is one in the
        # commit message.
        revision = args.revision_num
        if not revision:
            revision = commit_fields.get('revisionID', None)  # actually a URI

        # If a revision was found, update it.
        if revision:
            # The message to use when updating the revision (or None):
            commit_message = None

            # The message to amend to our local HEAD commit when done (or None):
            new_local_commit_message = None

            if args.edit:
                # Get the new commit message to use when updating the revision.
                commit_message = head_commit.message
                if not args.verbatim:
                    commit_message = phab_local.run_editor(
                        content=commit_message)
                    # Make sure we amend the head commit later.
                    new_local_commit_message = commit_message

            comment = args.message
            if not comment:
                comment = input('Comment for this update: ')

            # Update the differential revision, including the new diff ID and
            # any changes to the commit message:
            edit_result = api.edit_revision(
                revid=revision, diff_phid=diff_phid,
                commit_message=commit_message, comment=comment)

            # If the commit message was edited, amend the head commit now.
            if new_local_commit_message:
                new_head = phab_local.update_head_commit_message(
                    new_message=new_local_commit_message)
                # Update commits with the new commit head.
                diff_commits.pop()
                diff_commits.append(new_head)

            # Update the diff with the commit(s) we used.
            api.update_diff_local_commits(diff_id, diff_commits)

            info = api.lookup_revision(edit_result['id'])

            print('Updated revision:', info['uri'])
            return

        # No revision was specified, so create a new one.
        commit_message = diff_commits[-1].message
        if not args.verbatim:
            commit_message = phab_local.run_editor(content=commit_message)
        edit_result = api.edit_revision(diff_phid=diff_phid,
                                        commit_message=commit_message)

        # Amend the commit, then update the diff with the new commit(s).
        new_head = phab_local.update_local_commit_message(
            api.get_commit_message(revision_id=edit_result['id']))

        diff_commits.pop()
        diff_commits.append(new_head)
        api.update_diff_local_commits(diff_id, diff_commits)


def main():
    argv = sys.argv[1:]
    p = argparse.ArgumentParser(
        prog='git phab', formatter_class=argparse.RawDescriptionHelpFormatter,
        description=__doc__)
    subcommands = p.add_subparsers(title='subcommands',
                                   description='valid subcommands',
                                   help='additional help')

    verbosity_group = p.add_mutually_exclusive_group()
    verbosity_group.add_argument('-q', '--quiet', action='store_true',
                                 help='print less information')
    verbosity_group.add_argument('-v', '--verbose', action='store_true',
                                 help='print more information')

    parser_diff = subcommands.add_parser(
        'diff', description=cmd_diff.__doc__,
        help='upload a diff to Phabricator')
    parser_diff.add_argument(
        'commit',
        metavar='DIFF_BASE',
        nargs='?',
        help=('the commit to diff against '
              '(default is `git merge-base @{upstream} HEAD`, prompting if '
              'no upstream is set)'))
    parser_diff.add_argument(
        '--preview',
        '--only',
        dest='diff_only',
        action='store_true',
        help='only create a diff, not a Differential revision')
    parser_diff.add_argument(
        '--update',
        type=int,
        metavar='REVISION',
        dest='revision_num',
        # TODO: add a custom action to parse various formats.
        help='update a specific revision (numeric, i.e., no "D" prefix)')
    parser_diff.add_argument(
        '--message',
        '-m',
        metavar='MESSAGE',
        help='comment to attach to the revision update')
    parser_diff.add_argument(
        '--edit',
        action='store_true',
        help='edit the head commit message before uploading')
    parser_diff.add_argument(
        '--verbatim',
        action='store_true',
        help=('use the HEAD commit message to create or update the '
              'Differential Revision (without editing first)'))
    # TODO:
    # --ccs
    # --reviewers
    parser_diff.set_defaults(func=cmd_diff)

    args = p.parse_args()
    if not hasattr(args, 'func'):
        parser.print_help()
        parser.exit()
    args.func(args)


if __name__ == '__main__':
    main()
